#### [88. Merge Sorted Array](https://leetcode.cn/problems/merge-sorted-array/)

#easy #雙指針



## 題目描述

Given a **1-indexed** array of integers `numbers` that is already **sorted in non-decreasing order**, find two numbers such that they add up to a specific `target` number. Let these two numbers be `numbers[index1]` and `numbers[index2]` where `1 <= index1 < index2 <= numbers.length`.

Return the indices of the two numbers, `index1` and `index2`, **added by one** *as an integer array* `[index1, index2]` of *length 2*.

The tests are generated such that there is **exactly one solution**. You **may not** use the same element twice.

Your solution must use only constant extra space.



**Example 1:**

```text
Input: numbers = [2,7,11,15], target = 9
Output: [1,2]
Explanation: The sum of 2 and 7 is 9. Therefore, index1 = 1, index2 = 2. We return [1, 2].
```

**Example 2:**

```
Input: numbers = [2,3,4], target = 6
Output: [1,3]
Explanation: The sum of 2 and 4 is 6. Therefore index1 = 1, index2 = 3. We return [1, 3].
```

**Example 3:**

```
Input: numbers = [-1,0], target = -1
Output: [1,2]
Explanation: The sum of -1 and 0 is -1. Therefore index1 = 1, index2 = 2. We return [1, 2].

```



## 解題紀錄

#0109

被例外情形狠電

對insert() 和 pop() 的操作總是沒辦法通過所有的測試案例

```python
# ex1
nums1=[1]
m=1
nums2=[]
n=0

# ex2
nums1=[0]
m=0
nums2=[1]
n=1

#ex3
nums1=[2,0]
m=1
nums2=[1]
n=1

# while 條件
nums1=[4,0,0,0,0,0]
m=1
nums2=[1,2,3,5,6]
n=5
```





**Bug&盲點**

```python
# Do not return anything, modify nums1 in-place instead.
if m ==0:
  return nums2[:n]
if n ==0:
  return nums1[:m]

n1_ix=0
n2_ix=0
finals=[]
while n1_ix<m and n2_ix<n:
  if nums2[n2_ix]>nums1[n1_ix]:
    finals.append(nums1[n1_ix])
    n1_ix+=1
    else:
      #     elif num2[n2_ix]<=nums1[n1_ix]:
      finals.append(nums2[n2_ix])
      n2_ix+=1
      if n1_ix< m-1:
        return finals+nums1[n1_ix:]
      else:
        return finals+nums2[n2_ix:]

```



## Code

```python
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        left_ix=right_ix=1 #左指針從最小的值開始增序找 右指針從最大值開始減序找
        for i in range(len(numbers)-1):        
            # 左指針從左開始
            left=numbers[left_ix-1]
            # 右指針從右開始
            right=numbers[-right_ix]
            if left+right == target:
                return [left_ix, len(numbers)-right_ix+1] 
            # 相加後的值大於target，意指最大值太大須減少減序
            elif left+right > target:
                right_ix+=1
            # 相加後的值小於target，意味最小值還不夠大須增加
            else:
                left_ix+=1
```

![img_ac](https://github.com/youngmihuang/leetcode-python/blob/main/img/167.two_sum_II_input_array_is_sorted_ac.png)
