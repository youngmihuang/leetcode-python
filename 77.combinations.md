
* 花了 2 days 
* 使用 DFS 回朔法比 `itertools` 還要慢
算法複雜度只贏過 8% ; itertools 的方法算法和空間複雜度都可以贏過 90%+

```
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        def dfs(nums, i, res):
            # 終止條件
            if len(res) == k:
                final_res.append(res[:])
                print('inner', i, res[:])
                print('='*80)
                return
            for j in range(i, n):
                res.append(nums[j])
                print(j)
                dfs(nums, j+1, res)
                res.pop()
                    
        nums=[i for i in range(1,n+1)]
        res=[]
        final_res=[]
        dfs(nums, 0, res)
        
        return final_res
```

```
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
            return list(itertools.combinations(range(1,n+1),k))
```
